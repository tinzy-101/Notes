<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<title>2-13-24</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Review Test 2 Answers"><h3 id="Review Test 2 Answers" class="header"><a href="#Review Test 2 Answers">Review Test 2 Answers</a></h3></div>
<pre>
	EC:
		1. use TS() to implement mutual exclusion
		2. Test and set sets true to a boolean and return og contents (always set to true, regardless of og value) 
		3. Test and set doesn't have to be a privileged instruction, can run in user level
		4. true
		5. true 
</pre>

<div id="Team Project"><h3 id="Team Project" class="header"><a href="#Team Project">Team Project</a></h3></div>
<pre>
	1. go to team discussion, introduce self, wanted deliverable, choose leader (Team 3)
	2. choose linux distro
	3. leader email team distro to prof Linn by Tuesday 2/20/24
</pre>

<div id="Chapter 9: Main Memory"><h3 id="Chapter 9: Main Memory" class="header"><a href="#Chapter 9: Main Memory">Chapter 9: Main Memory</a></h3></div>
<pre>
	--&gt; program has to be brought from disk and loaded into mem + placed w/ process in order to run
	--&gt; main mem + registers = only sotrage CPU can access directly (CPU can't access disk)
	--&gt; mem only sees address + read/write requests for addresses 
	--&gt; main mem takes many cycles = stalling 
</pre>
<p>
<span id="Chapter 9: Main Memory-Base and Limit Registers"></span><strong id="Base and Limit Registers">Base and Limit Registers</strong>
</p>
<pre>
	--&gt; base + limit register define logical address space
	--&gt; CPU needs to check every mem access from user to make sure it falls b/w limits set by base + limit register
</pre>
<p>
<span id="Chapter 9: Main Memory-Hardware Address Protection"></span><strong id="Hardware Address Protection">Hardware Address Protection</strong>
</p>
<pre>
	--&gt; hardware makes sure that the limit and base registers are respected by user
</pre>
<p>
<span id="Chapter 9: Main Memory-Address Binding for Data and Memory: ON TEST"></span><strong id="Address Binding for Data and Memory: ON TEST">Address Binding for Data and Memory: ON TEST</strong>
</p>
<pre>
	--&gt; address binding of isntructions and data to mem address can happen at 3 stages
	1. at compile time, can generate physical and absolute memory locations 
		--&gt; important b/c interrupt vectors are in mem 
		--&gt; if OS decides to change this absolute address, need to recompile 
		--&gt; bind address in program to specific location in mem
			--&gt; e.g. dispatcher mem location is stored in mem vector scheme, easy access to data when performing context switch
			--&gt; need to recompile if dispatcher changes locations
	2. at load time, relocatable code is generated if mem location not known at compile time
		--&gt; on disk: relocatable addresses, addresses are adjusted when data loaded into mem
		--&gt; applies to most user programs, only OS can do absolute compile time addressing
	3. at execution time, every address in CPU is a relative address ("logical address")
		--&gt; when real address is fetched, relative address is decoded, which puts in the real address
		--&gt; every instruction fetch modified relative addresses to the real addresses in mem
			--&gt; "address translation"
		--&gt; need HARDWARE support to do mapping
</pre>
<p>
<span id="Chapter 9: Main Memory-Multistep Processing of a User Program"></span><strong id="Multistep Processing of a User Program">Multistep Processing of a User Program</strong>
</p>
<pre>
	execute program --&gt; compiler makes object module --&gt; load other object modules --&gt; link editor laods module --&gt; loader movies sys libraries in --&gt; program places in mem --&gt; dynamic libs linked
	
</pre>
<p>
<span id="Chapter 9: Main Memory-Logical vs Physical Address Space"></span><strong id="Logical vs Physical Address Space">Logical vs Physical Address Space</strong>
</p>
<pre>
	--&gt; logical address = generated by CPU ("virtual addresses"), translated into physical address
	--&gt; logical address space = set of all logical addresses gen by program
	--&gt; physical address space = " " physical addresses gen by program 
</pre>
<p>
<span id="Chapter 9: Main Memory-2 schemes of Mem"></span><strong id="2 schemes of Mem">2 schemes of Mem</strong>
</p>
<pre>
	Real Storage = use scheme w/ relative addresses OR absolute addresses 
		000 GoTo 100 (100 = offset)
		001
		010
		...
		
		--&gt; when program placed into mem...
		1CD000 GoTo 1CD100
		1CD001
		...
		1CD100 Pick...
			--&gt; addresses are adjusted to the proper address that it's going to 
</pre>
<p>
<span id="Chapter 9: Main Memory-Memory Management Unit (MMU)"></span><strong id="Memory Management Unit (MMU)">Memory Management Unit (MMU)</strong>
</p>
<pre>
	--&gt; base register = relocation register
	have address (know where located in memory) + offsets in instructions work with that 
</pre>
<p>
<span id="Chapter 9: Main Memory-Dynamic Linking"></span><strong id="Dynamic Linking">Dynamic Linking</strong>
</p>
<pre>
	--&gt; static linking = sys libs and program code combined by loader into bin program image
		--&gt; rare today
	--&gt; dynamic linking = wait until execution to start linking
		--&gt; use stub = locate appropriate binary routing in library 
		--&gt; stub replaces itself w/ address of routine + exec routing
		--&gt; OS checks if routine in process mem address
			--&gt;if not, add to address space
		--&gt; good for libraries 
			--&gt; problem: version control (need to change entry points when new features)
		
</pre>
<p>
<span id="Chapter 9: Main Memory-Swapping"></span><strong id="Swapping">Swapping</strong>
</p>
<pre>
	--&gt; want to switch from disk to main memory seamlessly for different processes
	--&gt; sometimes swapping disabled w/ updated/shared mem location
</pre>
<p>
<span id="Chapter 9: Main Memory-Context Switch Time including Swapping"></span><strong id="Context Switch Time including Swapping">Context Switch Time including Swapping</strong>
</p>
<pre>
	--&gt; context switch time can be long when including swapping 
</pre>
<p>
<span id="Chapter 9: Main Memory-Contiguous Allocation"></span><strong id="Contiguous Allocation">Contiguous Allocation</strong>
</p>
<pre>
	--&gt; whole program has to be in mem at one time AND contiguous in 1 mem block in order to exec AND stay in mem until done
	--&gt;
	--&gt; 2 mechanisms:
		1. fixed size partitions
		2. variable size partitions
</pre>
<p>
<span id="Chapter 9: Main Memory-Multiple Parition allocation"></span><strong id="Multiple Parition allocation">Multiple Parition allocation</strong>
</p>
<pre>
	--&gt; degree of multiprogramming limited by num partitions
	--&gt; variable partition sizes have efficiency
		--&gt; but create holes: blocks of avail mem
	--&gt; e.g. process 8 finishes running, leaves a hole in mem
		--&gt; 9 comes in, gets a bit of mem and partially fills hole
		--&gt; 10 comes in, gets a bit of mem and partially fills hole (still hole tho!)
</pre>
<p>
<span id="Chapter 9: Main Memory-Dynamic Storage Allocation Problem: ON TEST"></span><strong id="Dynamic Storage Allocation Problem: ON TEST">Dynamic Storage Allocation Problem: ON TEST</strong>
</p>
<pre>
	--&gt; what processes to fit into mem holes w/ multiple partiion alloc?
	--&gt; how to allocate holes?
	1. first fit: 
		--&gt; allocate first hole that is big enough
	2. best fit:
		--&gt; order holes by size
		--&gt; smallest hole thats big enough to biggest 
		--&gt; produces smallest leftover hole
	3. worse fit:
		--&gt; sort holes by largest, allocate largest hole
		--&gt; need to search whole list
		--&gt; produces largest leftover hole 
	
	--&gt; first fit and best fit best!!
	--&gt; OS chooses which scheme to use, depends on OS goals
</pre>
<p>
<span id="Chapter 9: Main Memory-Variable Allocation Example: ON TEST"></span><strong id="Variable Allocation Example: ON TEST">Variable Allocation Example: ON TEST</strong>
</p>
<pre>
	*holes b/w processes P1-P4 taking up mem*
	
	P5 needs 5k, P6 needs 35k
	
	Hole0 3k
	P1
	Hole1 5k
	P2
	Hole2 20k
	P3
	Hole3 30k
	P4
	
	first fit (for P5): hole 1
	best fit: hole 1
	worst fit: hole3
	
	sometimes, need to compact/garbage collection to reclaim the space, so P6 can have a hole big enough to run
		--&gt; e.g. give P5 Hole1
		--&gt; need to move P1, P2, P3 up, so can combine 3k + 20k + 50k = 53k hole for P6
</pre>
<p>
<span id="Chapter 9: Main Memory-Real Storage Properties"></span><strong id="Real Storage Properties">Real Storage Properties</strong>
</p>
<pre>
	1. contiguous
	2. all program loaded into main mem
	3. program stays in mem for lifetime
</pre>
<p>
<span id="Chapter 9: Main Memory-Fragmentation"></span><strong id="Fragmentation">Fragmentation</strong>
</p>
<pre>
	1. external fragmentation 
		--&gt; total mem space exists to satsify request, but not contiguous
		--&gt; reduce using compaction = garbage disposal = burping 
			--&gt; shuffle mem together, can't be fetched and executed while shuffling happening!
	2. internal frag
		--&gt; allocated mem might be lager than request mem 
		--&gt; program allocated mem but program not using it 
	--&gt; overlays: you can take a segment and replace it with any other program segment 
	--&gt; e.g. P2: 15k base segment
					 10k overlay segment
					 15k overlay segment (in mem)
					 --&gt; swap 10k overlay out for 15k if program needs 30k
					 --&gt; swap 10k back in when program no longer needs 30k
					 --&gt; leaves 5k internal fragmentation 
		--&gt; like swapping processes, but swapping mem segments in and out instead 
</pre>
<p>
<span id="Chapter 9: Main Memory-Segmentation"></span><strong id="Segmentation">Segmentation</strong>
</p>
<pre>
	--&gt; segment = logical unit of program (ALL have logical addresses)
		--&gt; e.g. main program, function, method, object, local and global vars, stack, arrays 
		--&gt; compilers puts these segments inside ur programs 
	--&gt; in virtual mem management, don't need segments to be contiguous to run program
		--&gt; vs real mem management, need segments to be contiguous 
</pre>
<p>
<span id="Chapter 9: Main Memory-Segmentation Architecture"></span><strong id="Segmentation Architecture">Segmentation Architecture</strong>
</p>
<pre>
	--&gt; need supporting hardware to make segmentation / virtual mem management to work
	--&gt; segment table
		--&gt; keeps track of segments + whether they're in mem at a time (valid segment)
		--&gt; keep track of read/write privileges on segment
	--&gt; segments have varying length, so again use dynamic allocation
	--&gt; this process is logical from program's perspective
	
	How it works:
		1. get starting address from segment table
		2. offset from that logical address to get physical address
</pre>
<p>
<span id="Chapter 9: Main Memory-Paging"></span><strong id="Paging">Paging</strong>
</p>
<pre>
	--&gt; physical size of segments, as opposed to virtual size (in segmentation)
	--&gt; address space can be noncontiguous
	--&gt; avoids external frag, but often internal frag issues
	--&gt; EVERY sys today uses paging
</pre>
<p>
<span id="Chapter 9: Main Memory-Address Translation Scheme"></span><strong id="Address Translation Scheme">Address Translation Scheme</strong>
</p>
<pre>
	--&gt; page num + offset inside page
	--&gt; offset size = exactly size on mem of a page 
		--&gt; e.g. offset = 2k, then page size in mem = 2k 
	--&gt; page num = how many bits available
</pre>
<p>
<span id="Chapter 9: Main Memory-Paging Hardware"></span><strong id="Paging Hardware">Paging Hardware</strong>
</p>
<pre>
	--&gt; page table + number
	--&gt; page num located physically in physical address
		--&gt; takes displacement from page table in page frame in physical mem 
</pre>
<p>
<span id="Chapter 9: Main Memory-Paging Model of Logical and Physical Mem"></span><strong id="Paging Model of Logical and Physical Mem">Paging Model of Logical and Physical Mem</strong>
</p>
<pre>
	--&gt; logical mem: pages generated by CPU
	--&gt; page table: shows physically which page its in in mem 
	--&gt; logical page 1 in program = physical page 3 in mem 
	--&gt; NOT contiguous 
</pre>

</body>
</html>
